<template>
  <style>
    :host {
      display: none;
    }
    :host(.active) {
      display: block;
    }
  </style>
  <slot></slot>
</template>
<script>
  let sfRoute = SFComponent['sf-route'];
  let clickEvents = {};
  sfRoute.observedAttributes = ['data-route'];
  sfRoute.attributeChangedCallback = function(el, attrName, oldVal, newVal) {
    if (attrName == 'data-route') {
      refreshRoute(el, SFComponent.getRoutes(window.location.pathname));
    }
  }

  clickEvents['a'] = function(el, e) {
    if (el.host == window.location.host) {
      e.preventDefault();
      var stateObj = {
        location: el.pathname
      };
      document.title = el.pathname;
      history.pushState(stateObj, "Home", el.pathname);
      refreshAllRoutes();
    }
  }

  window.onpopstate = function(event) {
    refreshAllRoutes();
  };

  function refreshAllRoutes() {
    let path = SFComponent.getRoutes(window.location.pathname);
    document.querySelectorAll('sf-route').forEach(function(el) {
      refreshRoute(el, path);
    });
  }

  function refreshRoute(el, path) {
    let route = SFComponent.getRoutes(el.dataset.route);
    let data = {};
    makeRouteInactive(el);
    for (const [i, r] of route.entries()) {
      if (r == '..') {
        makeRouteActive(el, data);
        return;
      } else if (typeof path[i] == 'undefined') {
        makeRouteInactive(el);
        return;
      } else if (r == path[i] || r == '*') {
        continue;
      } else if (r[0] == ':') {
        data[r.substr(1)] = path[i];
        continue;
      } else {
        makeRouteInactive(el);
        return
      }
    }
    makeRouteActive(el, data);
  }

  function makeRouteActive(el, data) {
    let newHtml = SFComponent.replace(el.dataset.originalSlotHtml, data, '#{route');
    if (el.innerHTML !== newHtml) {
      el.innerHTML = newHtml;
    }
    addClass(el, 'active');
  }

  function makeRouteInactive(el) {
    removeClass(el, 'active');
    if (!el.dataset.originalSlotHtml) {
      el.dataset.originalSlotHtml = el.innerHTML;
    }
    el.innerHTML = '';
  }

  function addClass(elem, classN) {
    if (typeof elem == "string") {
      elem = document.querySelector(elem);
    }
    if (!elem) {
      return false;
    }
    if (elem.className.length < 1) {
      elem.className = classN;
    }
    let classes = elem.className.split(" ");
    if (classes.indexOf(classN) < 0) {
      classes.push(classN);
    }
    elem.className = classes.join(" ");
  }

  function removeClass(elem, classN) {
    if (typeof elem == "string") {
      elem = document.querySelector(elem);
    }
    if (!elem) {
      return false;
    }
    let classes = elem.className.split(" ");
    classes.remove(classN);
    elem.className = classes.join(" ");
  }

  //Click event listner
  const MAIN = document.body || document.getElementsByTagName("body")[0];

  function clickHandler(e) {
    e = e || window.event;
    var target;
    target = e.target || e.srcElement;
    for (var k in clickEvents) {
      x = target;
      while (x) {
        if (x.matches(k)) {
          var fn = clickEvents[k];
          if (typeof fn === "function") {
            fn(x, e);
          }
        }
        if (x) {
          x = x.parentElement;
        }
      }
    }
  }

  if (MAIN.addEventListener) {
    MAIN.addEventListener('click', clickHandler, false);
  } else {
    MAIN.attachEvent('onclick', clickHandler);
  }
</script>