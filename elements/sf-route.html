<template>
  <style>
    :host {
      display: none;
    }
    :host(.active) {
      display: block;
    }
  </style>
  <slot></slot>
</template>
<script>
  let sfRoute = SFComponent['sf-route'];
  let clickEvents = {};
  sfRoute.observedAttributes = ['data-route'];
  sfRoute.attributeChangedCallback = function(el, attrName, oldVal, newVal) {
    if (attrName == 'data-route') {
      refreshRoute(el, window.location.pathname);
    }
  }

  clickEvents['a'] = function(el, e) {
    if (el.host == window.location.host) {
      e.preventDefault();
      var stateObj = {
        location: el.pathname
      };
      document.title = el.pathname;
      history.pushState(stateObj, "Home", el.pathname);
      refreshAllRoutes();
    }
  }

  window.onpopstate = function(event) {
    refreshAllRoutes();
  };

  function refreshAllRoutes() {
    let path = window.location.pathname;
    document.querySelectorAll('sf-route').forEach(function(el) {
      refreshRoute(el, path);
    });
  }

  function refreshRoute(el, path) {
    let route = el.dataset.route;
    let data = {
      star: []
    };
    makeRouteInactive(el);
    let active = false;
    let reg = new RegExp('^' + regExpEscape(route.replace(/\*\*/g, '.{0,}').replace(/\*/g, '[^/]{0,}').replace(/:[^\/]{0,}/g, '[^/]{0,}')));
    let pathSplit = SFComponent.getRoutes(path);
    for (const [i, r] of SFComponent.getRoutes(route).entries()) {
      if (r[0] == ':') {
        data[r.substr(1)] = pathSplit[i];
      } else if (r == '*') {
        data.star.push(pathSplit[i]);
      }
    }
    if (path.match(reg)) {
      makeRouteActive(el, data);
    }
  }

  function regExpEscape(s) {
    return s.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&');
  }

  function makeRouteActive(el, data) {
    let newHtml = SFComponent.replace(el.dataset.originalSlotHtml, {
      route: data
    });
    if (el.innerHTML !== newHtml) {
      el.innerHTML = newHtml;
    }
    addClass(el, 'active');
  }

  function makeRouteInactive(el) {
    removeClass(el, 'active');
    if (!el.dataset.originalSlotHtml) {
      el.dataset.originalSlotHtml = el.innerHTML.replace(/\<\!--\s*?[^\s?\[][\s\S]*?--\>/g, '')
        .replace(/\>\s*\</g, '><');
    }
    el.innerHTML = '';
  }

  function addClass(elem, classN) {
    if (typeof elem == "string") {
      elem = document.querySelector(elem);
    }
    if (!elem) {
      return false;
    }
    if (elem.className.length < 1) {
      elem.className = classN;
    }
    let classes = elem.className.split(" ");
    if (classes.indexOf(classN) < 0) {
      classes.push(classN);
    }
    elem.className = classes.join(" ");
  }

  function removeClass(elem, classN) {
    if (typeof elem == "string") {
      elem = document.querySelector(elem);
    }
    if (!elem) {
      return false;
    }
    let classes = elem.className.split(" ");
    classes.remove(classN);
    elem.className = classes.join(" ");
  }

  //Click event listner
  const MAIN = document.body || document.getElementsByTagName("body")[0];

  function clickHandler(e) {
    e = e || window.event;
    var target;
    target = e.target || e.srcElement;
    for (var k in clickEvents) {
      x = target;
      while (x) {
        if (x.matches(k)) {
          var fn = clickEvents[k];
          if (typeof fn === "function") {
            fn(x, e);
          }
        }
        if (x) {
          x = x.parentElement;
        }
      }
    }
  }

  if (MAIN.addEventListener) {
    MAIN.addEventListener('click', clickHandler, false);
  } else {
    MAIN.attachEvent('onclick', clickHandler);
  }

  Array.prototype.remove = function() {
    let what, a = arguments,
      L = a.length,
      ax;
    while (L && this.length) {
      what = a[--L];
      while ((ax = this.indexOf(what)) !== -1) {
        this.splice(ax, 1);
      }
    }
    return this;
  };
</script>